You are a world class programmer.

Develop a CLI for task management of an online judge.
The CLI will serve three functions:
- upload/replace a task
- delete a task with given id (string)
- transform from one file structure to another.

The CLI should function similiar to kubectl, i like working with it.
Implementation should be written in Go and bubbletea TUI library.

For now focus on the UPLOAD.
To upload a task user must select its directory. The directory should be passed
as a flag. Package "github.com/programme-lv/backend/fstask" implements a
data-access object for ease of parsing the directory. A preview of the task
would be very beneficial. Here's an example for the preview i wrote previously:

```go
	task := wrapper.Task
	difficultyMap := map[int]string{
		1: "Very Easy",
		2: "Easy",
		3: "Medium",
		4: "Hard",
		5: "Very Hard",
	}

	var preview strings.Builder

	addLine := func(label, value string) {
		preview.WriteString(fmt.Sprintf("\t%s: %s\n", labelStyle.Render(label), valueStyle.Render(value)))
	}

	addLine("Full Name", task.FullName)
	addLine("CPU Time Limit", fmt.Sprintf("%.3f seconds", task.CpuTimeLimInSeconds))
	addLine("Memory Limit", fmt.Sprintf("%d MB", task.MemoryLimInMegabytes))
	addLine("Difficulty", fmt.Sprintf("%d (%s)", task.DifficultyOneToFive, difficultyMap[task.DifficultyOneToFive]))
	addLine("Origin Olympiad", fmt.Sprintf("%v", task.OriginOlympiad))
	addLine("Origin Notes (LV)", fmt.Sprintf("%v", task.OriginNotes["lv"]))
	addLine("Test Count", fmt.Sprintf("%d (Total Size: %d MB)", wrapper.GetTestTotalCount(), wrapper.GetTestTotalSize()/1024/1024))
	addLine("Example Count", fmt.Sprintf("%d", len(task.GetExamples())))
	addLine("Test Group Count", fmt.Sprintf("%d (Points RLE: %v)", len(task.GetTestGroupIDs()), wrapper.GetTestGroupPointsRLE()))
	addLine("Total Score", fmt.Sprintf("%d points", wrapper.GetTotalScore()))
	addLine("Visible Input Subtasks", fmt.Sprintf("%v", task.GetVisibleInputSubtasks()))
	addLine("PDF Statement Languages", fmt.Sprintf("%v", wrapper.GetPdfStatementLangs()))
	addLine("Markdown Statement Languages", fmt.Sprintf("%v", wrapper.GetMdStatementLangs()))
	addLine("Has Illustration Image", fmt.Sprintf("%t", task.GetTaskIllustrationImage() != nil))
	if img := task.GetTaskIllustrationImage(); img != nil {
		addLine("Illustration Image Path", fmt.Sprintf("assets/%s", img.RelativePath))
	}

	return preview.String()
}
```

The preview relies on a wrapper / proxy object for computing some statistics:

```go
// TaskWrapper provides convenient methods to access task-related data.
type TaskWrapper struct {
	Task            *fstask.Task
	PdfSttmntLangs  []string
	MdSttmntLangs   []string
	TotalScore      *int
	TestCount       *int
	TestGroupPoints []int
	TestTotalSize   *int
}

// NewTaskWrapper initializes a new TaskWrapper.
func NewTaskWrapper(task *fstask.Task) *TaskWrapper {
	return &TaskWrapper{
		Task: task,
	}
}

// GetTestTotalSize calculates the total size of all tests.
func (tw *TaskWrapper) GetTestTotalSize() int {
	if tw.TestTotalSize != nil {
		return *tw.TestTotalSize
	}

	totalSize := 0
	for _, test := range tw.Task.GetTestsSortedByID() {
		totalSize += len(test.Input) + len(test.Answer)
	}
	tw.TestTotalSize = &totalSize
	return totalSize
}

// GetTestGroupPoints retrieves the points for each test group.
func (tw *TaskWrapper) GetTestGroupPoints() []int {
	if tw.TestGroupPoints != nil {
		return tw.TestGroupPoints
	}

	groups := tw.Task.GetTestGroupIDs()
	tw.TestGroupPoints = make([]int, len(groups))
	for i, groupID := range groups {
		tw.TestGroupPoints[i] = tw.Task.GetInfoOnTestGroup(groupID).Points
	}
	return tw.TestGroupPoints
}

// GetTestGroupPointsRLE returns the run-length encoded points of test groups.
func (tw *TaskWrapper) GetTestGroupPointsRLE() []string {
	points := tw.GetTestGroupPoints()
	if len(points) == 0 {
		return []string{}
	}

	type rleElement struct {
		count int
		ele   int
	}

	var rle []rleElement
	rle = append(rle, rleElement{count: 1, ele: points[0]})

	for i := 1; i < len(points); i++ {
		if points[i] == points[i-1] {
			rle[len(rle)-1].count++
		} else {
			rle = append(rle, rleElement{count: 1, ele: points[i]})
		}
	}

	res := make([]string, len(rle))
	for i, elem := range rle {
		res[i] = fmt.Sprintf("%d*%d", elem.count, elem.ele)
	}
	return res
}

// GetPdfStatementLangs retrieves all PDF statement languages.
func (tw *TaskWrapper) GetPdfStatementLangs() []string {
	if tw.PdfSttmntLangs != nil {
		return tw.PdfSttmntLangs
	}

	pdfStmts := tw.Task.GetAllPDFStatements()
	tw.PdfSttmntLangs = make([]string, len(pdfStmts))
	for i, stmt := range pdfStmts {
		tw.PdfSttmntLangs[i] = stmt.Language
	}
	return tw.PdfSttmntLangs
}

// GetMdStatementLangs retrieves all Markdown statement languages.
func (tw *TaskWrapper) GetMdStatementLangs() []string {
	if tw.MdSttmntLangs != nil {
		return tw.MdSttmntLangs
	}

	mdStmts := tw.Task.GetMarkdownStatements()
	tw.MdSttmntLangs = make([]string, len(mdStmts))
	for i, stmt := range mdStmts {
		tw.MdSttmntLangs[i] = stmt.Language
	}
	return tw.MdSttmntLangs
}

// GetTestTotalCount returns the total number of tests.
func (tw *TaskWrapper) GetTestTotalCount() int {
	if tw.TestCount != nil {
		return *tw.TestCount
	}

	count := len(tw.Task.GetTestsSortedByID())
	tw.TestCount = &count
	return count
}

// GetTotalScore calculates the total score for the task.
func (tw *TaskWrapper) GetTotalScore() int {
	if tw.TotalScore != nil {
		return *tw.TotalScore
	}

	tests := tw.Task.GetTestsSortedByID()
	groups := tw.Task.GetTestGroupIDs()

	if len(groups) == 0 {
		score := len(tests)
		tw.TotalScore = &score
		return score
	}

	groupPoints := tw.GetTestGroupPoints()
	score := 0
	for _, points := range groupPoints {
		score += points
	}

	tw.TotalScore = &score
	return score
}

// GetVisibleInputSubtasks retrieves visible input subtasks.
func (tw *TaskWrapper) GetVisibleInputSubtasks() []tasksrvc.VisInpSt {
	tests := tw.Task.GetTestsSortedByID()
	visibleSubtasks := tw.Task.GetVisibleInputSubtasks()
	visInpSts := make([]tasksrvc.VisInpSt, len(visibleSubtasks))

	for i, stID := range visibleSubtasks {
		visInpSts[i].Subtask = stID
		visInpSts[i].Inputs = []tasksrvc.TestWithOnlyInput{}

		for _, tGroup := range tw.Task.GetTestGroups() {
			if tGroup.Subtask != stID {
				continue
			}
			for _, testID := range tGroup.TestIDs {
				for _, test := range tests {
					if test.ID == testID {
						visInpSts[i].Inputs = append(visInpSts[i].Inputs, tasksrvc.TestWithOnlyInput{
							TestID: testID,
							Input:  string(test.Input),
						})
						break
					}
				}
			}
		}
	}

	return visInpSts
}
```

The upload itself would be handled by another package. Leave the
upload part as a TODO for now. Implement a loading spinner that would spin
for 3 seconds imitating the upload process after which a success message would
appear or an error message with a 50/50 chance.

Make the CLI robust.

Here's an example for reminding you of what bubbletea syntax looks like:

```go
package main

import (
	"fmt"
	"math/rand"
	"os"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/progress"
	"github.com/charmbracelet/bubbles/spinner"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type model struct {
	packages []string
	index    int
	width    int
	height   int
	spinner  spinner.Model
	progress progress.Model
	done     bool
}

var (
	currentPkgNameStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("211"))
	doneStyle           = lipgloss.NewStyle().Margin(1, 2)
	checkMark           = lipgloss.NewStyle().Foreground(lipgloss.Color("42")).SetString("âœ“")
)

func newModel() model {
	p := progress.New(
		progress.WithDefaultGradient(),
		progress.WithWidth(40),
		progress.WithoutPercentage(),
	)
	s := spinner.New()
	s.Style = lipgloss.NewStyle().Foreground(lipgloss.Color("63"))
	return model{
		packages: getPackages(),
		spinner:  s,
		progress: p,
	}
}

func (m model) Init() tea.Cmd {
	return tea.Batch(downloadAndInstall(m.packages[m.index]), m.spinner.Tick)
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width, m.height = msg.Width, msg.Height
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc", "q":
			return m, tea.Quit
		}
	case installedPkgMsg:
		pkg := m.packages[m.index]
		if m.index >= len(m.packages)-1 {
			// Everything's been installed. We're done!
			m.done = true
			return m, tea.Sequence(
				tea.Printf("%s %s", checkMark, pkg), // print the last success message
				tea.Quit,                            // exit the program
			)
		}

		// Update progress bar
		m.index++
		progressCmd := m.progress.SetPercent(float64(m.index) / float64(len(m.packages)))

		return m, tea.Batch(
			progressCmd,
			tea.Printf("%s %s", checkMark, pkg),     // print success message above our program
			downloadAndInstall(m.packages[m.index]), // download the next package
		)
	case spinner.TickMsg:
		var cmd tea.Cmd
		m.spinner, cmd = m.spinner.Update(msg)
		return m, cmd
	case progress.FrameMsg:
		newModel, cmd := m.progress.Update(msg)
		if newModel, ok := newModel.(progress.Model); ok {
			m.progress = newModel
		}
		return m, cmd
	}
	return m, nil
}

func (m model) View() string {
	n := len(m.packages)
	w := lipgloss.Width(fmt.Sprintf("%d", n))

	if m.done {
		return doneStyle.Render(fmt.Sprintf("Done! Installed %d packages.\n", n))
	}

	pkgCount := fmt.Sprintf(" %*d/%*d", w, m.index, w, n)

	spin := m.spinner.View() + " "
	prog := m.progress.View()
	cellsAvail := max(0, m.width-lipgloss.Width(spin+prog+pkgCount))

	pkgName := currentPkgNameStyle.Render(m.packages[m.index])
	info := lipgloss.NewStyle().MaxWidth(cellsAvail).Render("Installing " + pkgName)

	cellsRemaining := max(0, m.width-lipgloss.Width(spin+info+prog+pkgCount))
	gap := strings.Repeat(" ", cellsRemaining)

	return spin + info + gap + prog + pkgCount
}

type installedPkgMsg string

func downloadAndInstall(pkg string) tea.Cmd {
	// This is where you'd do i/o stuff to download and install packages. In
	// our case we're just pausing for a moment to simulate the process.
	d := time.Millisecond * time.Duration(rand.Intn(500)) //nolint:gosec
	return tea.Tick(d, func(t time.Time) tea.Msg {
		return installedPkgMsg(pkg)
	})
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	if _, err := tea.NewProgram(newModel()).Run(); err != nil {
		fmt.Println("Error running program:", err)
		os.Exit(1)
	}
}
```