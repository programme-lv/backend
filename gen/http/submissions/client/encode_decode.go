// Code generated by goa v3.18.2, DO NOT EDIT.
//
// submissions HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/programme-lv/backend/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	submissions "github.com/programme-lv/backend/gen/submissions"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateSubmissionRequest instantiates a HTTP request object with method
// and path set to call the "submissions" service "createSubmission" endpoint
func (c *Client) BuildCreateSubmissionRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateSubmissionSubmissionsPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("submissions", "createSubmission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateSubmissionRequest returns an encoder for requests sent to the
// submissions createSubmission server.
func EncodeCreateSubmissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*submissions.CreateSubmissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("submissions", "createSubmission", "*submissions.CreateSubmissionPayload", v)
		}
		body := NewCreateSubmissionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("submissions", "createSubmission", err)
		}
		return nil
	}
}

// DecodeCreateSubmissionResponse returns a decoder for responses returned by
// the submissions createSubmission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateSubmissionResponse may return the following errors:
//   - "InternalError" (type submissions.InternalError): http.StatusInternalServerError
//   - "InvalidSubmissionDetails" (type submissions.InvalidSubmissionDetails): http.StatusBadRequest
//   - "NotFound" (type submissions.NotFound): http.StatusNotFound
//   - "unauthorized" (type submissions.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeCreateSubmissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateSubmissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			err = ValidateCreateSubmissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("submissions", "createSubmission", err)
			}
			res := NewCreateSubmissionSubmissionCreated(&body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionInternalError(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionInvalidSubmissionDetails(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionNotFound(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("submissions", "createSubmission", resp.StatusCode, string(body))
		}
	}
}

// BuildListSubmissionsRequest instantiates a HTTP request object with method
// and path set to call the "submissions" service "listSubmissions" endpoint
func (c *Client) BuildListSubmissionsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListSubmissionsSubmissionsPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("submissions", "listSubmissions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListSubmissionsResponse returns a decoder for responses returned by
// the submissions listSubmissions endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListSubmissionsResponse may return the following errors:
//   - "InternalError" (type submissions.InternalError): http.StatusInternalServerError
//   - "InvalidSubmissionDetails" (type submissions.InvalidSubmissionDetails): http.StatusBadRequest
//   - "NotFound" (type submissions.NotFound): http.StatusNotFound
//   - "unauthorized" (type submissions.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListSubmissionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListSubmissionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateSubmissionResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("submissions", "listSubmissions", err)
			}
			res := NewListSubmissionsSubmissionOK(body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsInternalError(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsInvalidSubmissionDetails(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsNotFound(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("submissions", "listSubmissions", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSubmissionRequest instantiates a HTTP request object with method and
// path set to call the "submissions" service "getSubmission" endpoint
func (c *Client) BuildGetSubmissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*submissions.GetSubmissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("submissions", "getSubmission", "*submissions.GetSubmissionPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSubmissionSubmissionsPath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("submissions", "getSubmission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetSubmissionResponse returns a decoder for responses returned by the
// submissions getSubmission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetSubmissionResponse may return the following errors:
//   - "InternalError" (type submissions.InternalError): http.StatusInternalServerError
//   - "InvalidSubmissionDetails" (type submissions.InvalidSubmissionDetails): http.StatusBadRequest
//   - "NotFound" (type submissions.NotFound): http.StatusNotFound
//   - "unauthorized" (type submissions.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetSubmissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSubmissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			err = ValidateGetSubmissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("submissions", "getSubmission", err)
			}
			res := NewGetSubmissionSubmissionOK(&body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionInternalError(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionInvalidSubmissionDetails(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionNotFound(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("submissions", "getSubmission", resp.StatusCode, string(body))
		}
	}
}

// unmarshalEvaluationResponseBodyToSubmissionsEvaluation builds a value of
// type *submissions.Evaluation from a value of type *EvaluationResponseBody.
func unmarshalEvaluationResponseBodyToSubmissionsEvaluation(v *EvaluationResponseBody) *submissions.Evaluation {
	res := &submissions.Evaluation{
		UUID:          *v.UUID,
		Status:        *v.Status,
		ReceivedScore: *v.ReceivedScore,
		PossibleScore: *v.PossibleScore,
	}

	return res
}

// unmarshalProgrammingLangResponseBodyToSubmissionsProgrammingLang builds a
// value of type *submissions.ProgrammingLang from a value of type
// *ProgrammingLangResponseBody.
func unmarshalProgrammingLangResponseBodyToSubmissionsProgrammingLang(v *ProgrammingLangResponseBody) *submissions.ProgrammingLang {
	res := &submissions.ProgrammingLang{
		ID:       *v.ID,
		FullName: *v.FullName,
		MonacoID: *v.MonacoID,
	}

	return res
}

// unmarshalTaskResponseBodyToSubmissionsTask builds a value of type
// *submissions.Task from a value of type *TaskResponseBody.
func unmarshalTaskResponseBodyToSubmissionsTask(v *TaskResponseBody) *submissions.Task {
	res := &submissions.Task{
		PublishedTaskID:        *v.PublishedTaskID,
		TaskFullName:           *v.TaskFullName,
		MemoryLimitMegabytes:   *v.MemoryLimitMegabytes,
		CPUTimeLimitSeconds:    *v.CPUTimeLimitSeconds,
		OriginOlympiad:         *v.OriginOlympiad,
		IllustrationImgURL:     v.IllustrationImgURL,
		DifficultyRating:       *v.DifficultyRating,
		DefaultPdfStatementURL: v.DefaultPdfStatementURL,
	}
	if v.DefaultMdStatement != nil {
		res.DefaultMdStatement = unmarshalMarkdownStatementResponseBodyToSubmissionsMarkdownStatement(v.DefaultMdStatement)
	}
	if v.Examples != nil {
		res.Examples = make([]*submissions.Example, len(v.Examples))
		for i, val := range v.Examples {
			res.Examples[i] = unmarshalExampleResponseBodyToSubmissionsExample(val)
		}
	}
	if v.OriginNotes != nil {
		res.OriginNotes = make(map[string]string, len(v.OriginNotes))
		for key, val := range v.OriginNotes {
			tk := key
			tv := val
			res.OriginNotes[tk] = tv
		}
	}
	if v.VisibleInputSubtasks != nil {
		res.VisibleInputSubtasks = make([]*submissions.StInputs, len(v.VisibleInputSubtasks))
		for i, val := range v.VisibleInputSubtasks {
			res.VisibleInputSubtasks[i] = unmarshalStInputsResponseBodyToSubmissionsStInputs(val)
		}
	}

	return res
}

// unmarshalMarkdownStatementResponseBodyToSubmissionsMarkdownStatement builds
// a value of type *submissions.MarkdownStatement from a value of type
// *MarkdownStatementResponseBody.
func unmarshalMarkdownStatementResponseBodyToSubmissionsMarkdownStatement(v *MarkdownStatementResponseBody) *submissions.MarkdownStatement {
	if v == nil {
		return nil
	}
	res := &submissions.MarkdownStatement{
		Story:   *v.Story,
		Input:   *v.Input,
		Output:  *v.Output,
		Notes:   v.Notes,
		Scoring: v.Scoring,
	}

	return res
}

// unmarshalExampleResponseBodyToSubmissionsExample builds a value of type
// *submissions.Example from a value of type *ExampleResponseBody.
func unmarshalExampleResponseBodyToSubmissionsExample(v *ExampleResponseBody) *submissions.Example {
	if v == nil {
		return nil
	}
	res := &submissions.Example{
		Input:  *v.Input,
		Output: *v.Output,
		MdNote: v.MdNote,
	}

	return res
}

// unmarshalStInputsResponseBodyToSubmissionsStInputs builds a value of type
// *submissions.StInputs from a value of type *StInputsResponseBody.
func unmarshalStInputsResponseBodyToSubmissionsStInputs(v *StInputsResponseBody) *submissions.StInputs {
	if v == nil {
		return nil
	}
	res := &submissions.StInputs{
		Subtask: *v.Subtask,
	}
	res.Inputs = make([]string, len(v.Inputs))
	for i, val := range v.Inputs {
		res.Inputs[i] = val
	}

	return res
}

// unmarshalSubmissionResponseToSubmissionsSubmission builds a value of type
// *submissions.Submission from a value of type *SubmissionResponse.
func unmarshalSubmissionResponseToSubmissionsSubmission(v *SubmissionResponse) *submissions.Submission {
	res := &submissions.Submission{
		UUID:       *v.UUID,
		Submission: *v.Submission,
		Username:   *v.Username,
		CreatedAt:  *v.CreatedAt,
	}
	res.Evaluation = unmarshalEvaluationResponseToSubmissionsEvaluation(v.Evaluation)
	res.Language = unmarshalProgrammingLangResponseToSubmissionsProgrammingLang(v.Language)
	res.Task = unmarshalTaskResponseToSubmissionsTask(v.Task)

	return res
}

// unmarshalEvaluationResponseToSubmissionsEvaluation builds a value of type
// *submissions.Evaluation from a value of type *EvaluationResponse.
func unmarshalEvaluationResponseToSubmissionsEvaluation(v *EvaluationResponse) *submissions.Evaluation {
	res := &submissions.Evaluation{
		UUID:          *v.UUID,
		Status:        *v.Status,
		ReceivedScore: *v.ReceivedScore,
		PossibleScore: *v.PossibleScore,
	}

	return res
}

// unmarshalProgrammingLangResponseToSubmissionsProgrammingLang builds a value
// of type *submissions.ProgrammingLang from a value of type
// *ProgrammingLangResponse.
func unmarshalProgrammingLangResponseToSubmissionsProgrammingLang(v *ProgrammingLangResponse) *submissions.ProgrammingLang {
	res := &submissions.ProgrammingLang{
		ID:       *v.ID,
		FullName: *v.FullName,
		MonacoID: *v.MonacoID,
	}

	return res
}

// unmarshalTaskResponseToSubmissionsTask builds a value of type
// *submissions.Task from a value of type *TaskResponse.
func unmarshalTaskResponseToSubmissionsTask(v *TaskResponse) *submissions.Task {
	res := &submissions.Task{
		PublishedTaskID:        *v.PublishedTaskID,
		TaskFullName:           *v.TaskFullName,
		MemoryLimitMegabytes:   *v.MemoryLimitMegabytes,
		CPUTimeLimitSeconds:    *v.CPUTimeLimitSeconds,
		OriginOlympiad:         *v.OriginOlympiad,
		IllustrationImgURL:     v.IllustrationImgURL,
		DifficultyRating:       *v.DifficultyRating,
		DefaultPdfStatementURL: v.DefaultPdfStatementURL,
	}
	if v.DefaultMdStatement != nil {
		res.DefaultMdStatement = unmarshalMarkdownStatementResponseToSubmissionsMarkdownStatement(v.DefaultMdStatement)
	}
	if v.Examples != nil {
		res.Examples = make([]*submissions.Example, len(v.Examples))
		for i, val := range v.Examples {
			res.Examples[i] = unmarshalExampleResponseToSubmissionsExample(val)
		}
	}
	if v.OriginNotes != nil {
		res.OriginNotes = make(map[string]string, len(v.OriginNotes))
		for key, val := range v.OriginNotes {
			tk := key
			tv := val
			res.OriginNotes[tk] = tv
		}
	}
	if v.VisibleInputSubtasks != nil {
		res.VisibleInputSubtasks = make([]*submissions.StInputs, len(v.VisibleInputSubtasks))
		for i, val := range v.VisibleInputSubtasks {
			res.VisibleInputSubtasks[i] = unmarshalStInputsResponseToSubmissionsStInputs(val)
		}
	}

	return res
}

// unmarshalMarkdownStatementResponseToSubmissionsMarkdownStatement builds a
// value of type *submissions.MarkdownStatement from a value of type
// *MarkdownStatementResponse.
func unmarshalMarkdownStatementResponseToSubmissionsMarkdownStatement(v *MarkdownStatementResponse) *submissions.MarkdownStatement {
	if v == nil {
		return nil
	}
	res := &submissions.MarkdownStatement{
		Story:   *v.Story,
		Input:   *v.Input,
		Output:  *v.Output,
		Notes:   v.Notes,
		Scoring: v.Scoring,
	}

	return res
}

// unmarshalExampleResponseToSubmissionsExample builds a value of type
// *submissions.Example from a value of type *ExampleResponse.
func unmarshalExampleResponseToSubmissionsExample(v *ExampleResponse) *submissions.Example {
	if v == nil {
		return nil
	}
	res := &submissions.Example{
		Input:  *v.Input,
		Output: *v.Output,
		MdNote: v.MdNote,
	}

	return res
}

// unmarshalStInputsResponseToSubmissionsStInputs builds a value of type
// *submissions.StInputs from a value of type *StInputsResponse.
func unmarshalStInputsResponseToSubmissionsStInputs(v *StInputsResponse) *submissions.StInputs {
	if v == nil {
		return nil
	}
	res := &submissions.StInputs{
		Subtask: *v.Subtask,
	}
	res.Inputs = make([]string, len(v.Inputs))
	for i, val := range v.Inputs {
		res.Inputs[i] = val
	}

	return res
}
