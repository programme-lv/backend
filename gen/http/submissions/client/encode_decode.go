// Code generated by goa v3.18.2, DO NOT EDIT.
//
// submissions HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/programme-lv/backend/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	submissions "github.com/programme-lv/backend/gen/submissions"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateSubmissionRequest instantiates a HTTP request object with method
// and path set to call the "submissions" service "createSubmission" endpoint
func (c *Client) BuildCreateSubmissionRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateSubmissionSubmissionsPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("submissions", "createSubmission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateSubmissionRequest returns an encoder for requests sent to the
// submissions createSubmission server.
func EncodeCreateSubmissionRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*submissions.CreateSubmissionPayload)
		if !ok {
			return goahttp.ErrInvalidType("submissions", "createSubmission", "*submissions.CreateSubmissionPayload", v)
		}
		{
			head := p.Token
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewCreateSubmissionRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("submissions", "createSubmission", err)
		}
		return nil
	}
}

// DecodeCreateSubmissionResponse returns a decoder for responses returned by
// the submissions createSubmission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateSubmissionResponse may return the following errors:
//   - "InternalError" (type submissions.InternalError): http.StatusInternalServerError
//   - "InvalidSubmissionDetails" (type submissions.InvalidSubmissionDetails): http.StatusBadRequest
//   - "NotFound" (type submissions.NotFound): http.StatusNotFound
//   - "unauthorized" (type submissions.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeCreateSubmissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateSubmissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			err = ValidateCreateSubmissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("submissions", "createSubmission", err)
			}
			res := NewCreateSubmissionSubmissionCreated(&body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionInternalError(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionInvalidSubmissionDetails(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionNotFound(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "createSubmission", err)
			}
			return nil, NewCreateSubmissionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("submissions", "createSubmission", resp.StatusCode, string(body))
		}
	}
}

// BuildListSubmissionsRequest instantiates a HTTP request object with method
// and path set to call the "submissions" service "listSubmissions" endpoint
func (c *Client) BuildListSubmissionsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListSubmissionsSubmissionsPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("submissions", "listSubmissions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeListSubmissionsResponse returns a decoder for responses returned by
// the submissions listSubmissions endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeListSubmissionsResponse may return the following errors:
//   - "InternalError" (type submissions.InternalError): http.StatusInternalServerError
//   - "InvalidSubmissionDetails" (type submissions.InvalidSubmissionDetails): http.StatusBadRequest
//   - "NotFound" (type submissions.NotFound): http.StatusNotFound
//   - "unauthorized" (type submissions.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeListSubmissionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListSubmissionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateSubmissionResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("submissions", "listSubmissions", err)
			}
			res := NewListSubmissionsSubmissionOK(body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsInternalError(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsInvalidSubmissionDetails(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsNotFound(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "listSubmissions", err)
			}
			return nil, NewListSubmissionsUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("submissions", "listSubmissions", resp.StatusCode, string(body))
		}
	}
}

// BuildGetSubmissionRequest instantiates a HTTP request object with method and
// path set to call the "submissions" service "getSubmission" endpoint
func (c *Client) BuildGetSubmissionRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uuid string
	)
	{
		p, ok := v.(*submissions.GetSubmissionPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("submissions", "getSubmission", "*submissions.GetSubmissionPayload", v)
		}
		uuid = p.UUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetSubmissionSubmissionsPath(uuid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("submissions", "getSubmission", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeGetSubmissionResponse returns a decoder for responses returned by the
// submissions getSubmission endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetSubmissionResponse may return the following errors:
//   - "InternalError" (type submissions.InternalError): http.StatusInternalServerError
//   - "InvalidSubmissionDetails" (type submissions.InvalidSubmissionDetails): http.StatusBadRequest
//   - "NotFound" (type submissions.NotFound): http.StatusNotFound
//   - "unauthorized" (type submissions.Unauthorized): http.StatusUnauthorized
//   - error: internal error
func DecodeGetSubmissionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetSubmissionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			err = ValidateGetSubmissionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("submissions", "getSubmission", err)
			}
			res := NewGetSubmissionSubmissionOK(&body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionInternalError(body)
		case http.StatusBadRequest:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionInvalidSubmissionDetails(body)
		case http.StatusNotFound:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionNotFound(body)
		case http.StatusUnauthorized:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("submissions", "getSubmission", err)
			}
			return nil, NewGetSubmissionUnauthorized(body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("submissions", "getSubmission", resp.StatusCode, string(body))
		}
	}
}

// unmarshalEvaluationResponseBodyToSubmissionsEvaluation builds a value of
// type *submissions.Evaluation from a value of type *EvaluationResponseBody.
func unmarshalEvaluationResponseBodyToSubmissionsEvaluation(v *EvaluationResponseBody) *submissions.Evaluation {
	res := &submissions.Evaluation{
		UUID:          *v.UUID,
		Status:        *v.Status,
		ReceivedScore: *v.ReceivedScore,
		PossibleScore: *v.PossibleScore,
	}

	return res
}

// unmarshalProgrammingLangResponseBodyToSubmissionsProgrammingLang builds a
// value of type *submissions.ProgrammingLang from a value of type
// *ProgrammingLangResponseBody.
func unmarshalProgrammingLangResponseBodyToSubmissionsProgrammingLang(v *ProgrammingLangResponseBody) *submissions.ProgrammingLang {
	res := &submissions.ProgrammingLang{
		ID:       *v.ID,
		FullName: *v.FullName,
		MonacoID: *v.MonacoID,
	}

	return res
}

// unmarshalSubmTaskResponseBodyToSubmissionsSubmTask builds a value of type
// *submissions.SubmTask from a value of type *SubmTaskResponseBody.
func unmarshalSubmTaskResponseBodyToSubmissionsSubmTask(v *SubmTaskResponseBody) *submissions.SubmTask {
	res := &submissions.SubmTask{
		Name: *v.Name,
		Code: *v.Code,
	}

	return res
}

// unmarshalSubmissionResponseToSubmissionsSubmission builds a value of type
// *submissions.Submission from a value of type *SubmissionResponse.
func unmarshalSubmissionResponseToSubmissionsSubmission(v *SubmissionResponse) *submissions.Submission {
	res := &submissions.Submission{
		UUID:       *v.UUID,
		Submission: *v.Submission,
		Username:   *v.Username,
		CreatedAt:  *v.CreatedAt,
	}
	res.Evaluation = unmarshalEvaluationResponseToSubmissionsEvaluation(v.Evaluation)
	res.Language = unmarshalProgrammingLangResponseToSubmissionsProgrammingLang(v.Language)
	res.Task = unmarshalSubmTaskResponseToSubmissionsSubmTask(v.Task)

	return res
}

// unmarshalEvaluationResponseToSubmissionsEvaluation builds a value of type
// *submissions.Evaluation from a value of type *EvaluationResponse.
func unmarshalEvaluationResponseToSubmissionsEvaluation(v *EvaluationResponse) *submissions.Evaluation {
	res := &submissions.Evaluation{
		UUID:          *v.UUID,
		Status:        *v.Status,
		ReceivedScore: *v.ReceivedScore,
		PossibleScore: *v.PossibleScore,
	}

	return res
}

// unmarshalProgrammingLangResponseToSubmissionsProgrammingLang builds a value
// of type *submissions.ProgrammingLang from a value of type
// *ProgrammingLangResponse.
func unmarshalProgrammingLangResponseToSubmissionsProgrammingLang(v *ProgrammingLangResponse) *submissions.ProgrammingLang {
	res := &submissions.ProgrammingLang{
		ID:       *v.ID,
		FullName: *v.FullName,
		MonacoID: *v.MonacoID,
	}

	return res
}

// unmarshalSubmTaskResponseToSubmissionsSubmTask builds a value of type
// *submissions.SubmTask from a value of type *SubmTaskResponse.
func unmarshalSubmTaskResponseToSubmissionsSubmTask(v *SubmTaskResponse) *submissions.SubmTask {
	res := &submissions.SubmTask{
		Name: *v.Name,
		Code: *v.Code,
	}

	return res
}
